var T = Object.defineProperty;
var f = Object.getOwnPropertySymbols;
var m = Object.prototype.hasOwnProperty, p = Object.prototype.propertyIsEnumerable;
var a = (e, t, r) => t in e ? T(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, d = (e, t) => {
  for (var r in t || (t = {}))
    m.call(t, r) && a(e, r, t[r]);
  if (f)
    for (var r of f(t))
      p.call(t, r) && a(e, r, t[r]);
  return e;
};
var E = (e, t) => {
  var r = {};
  for (var n in e)
    m.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && f)
    for (var n of f(e))
      t.indexOf(n) < 0 && p.call(e, n) && (r[n] = e[n]);
  return r;
};
import g, { useRef as D, useEffect as h } from "react";
import y from "prop-types";
import { getFocusableNodes as v } from "../helpers/getFocusableNodes.js";
import { KeyboardKeys as b } from "../helpers/keyboardKeys.js";
const F = (n) => {
  var u = n, { onEscape: e, restoreFocus: t } = u, r = E(u, ["onEscape", "restoreFocus"]);
  const c = D(null);
  h(() => {
    let o = null;
    return t && (o = document.activeElement), () => {
      o && o.focus();
    };
  }, [t]), h(() => {
    if (!c.current)
      return;
    const o = v(c.current);
    o.length > 0 ? o[0].focus() : console.warn(
      "[FocusTrap]: it seems there are no focusable elements in the focus trap tree. Make sure there s at least one."
    );
  }, []);
  const K = (o) => {
    if (o.key === b.ESCAPE && e) {
      e();
      return;
    }
    if (o.key !== b.TAB)
      return;
    const s = v(c.current);
    if (s.length > 0) {
      const l = s[0], i = s[s.length - 1];
      o.shiftKey ? l === document.activeElement && (o.preventDefault(), i.focus()) : i === document.activeElement && (o.preventDefault(), l.focus());
    }
  };
  return /* @__PURE__ */ g.createElement("div", d({
    ref: c,
    onKeyDown: K
  }, r));
};
F.defaultProps = {
  onEscape: void 0,
  restoreFocus: !0
};
F.propTypes = {
  onEscape: y.func,
  restoreFocus: y.bool
};
export {
  F as FocusTrap
};
