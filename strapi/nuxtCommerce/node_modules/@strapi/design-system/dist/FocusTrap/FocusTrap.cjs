"use strict";var T=Object.defineProperty;var c=Object.getOwnPropertySymbols;var y=Object.prototype.hasOwnProperty,b=Object.prototype.propertyIsEnumerable;var p=(e,t,s)=>t in e?T(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,m=(e,t)=>{for(var s in t||(t={}))y.call(t,s)&&p(e,s,t[s]);if(c)for(var s of c(t))b.call(t,s)&&p(e,s,t[s]);return e};var E=(e,t)=>{var s={};for(var r in e)y.call(e,r)&&t.indexOf(r)<0&&(s[r]=e[r]);if(e!=null&&c)for(var r of c(e))t.indexOf(r)<0&&b.call(e,r)&&(s[r]=e[r]);return s};Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const l=require("react"),_=require("prop-types"),h=require("../helpers/getFocusableNodes.cjs"),g=require("../helpers/keyboardKeys.cjs"),F=e=>e&&typeof e=="object"&&"default"in e?e:{default:e},k=F(l),v=F(_),a=r=>{var f=r,{onEscape:e,restoreFocus:t}=f,s=E(f,["onEscape","restoreFocus"]);const u=l.useRef(null);l.useEffect(()=>{let o=null;return t&&(o=document.activeElement),()=>{o&&o.focus()}},[t]),l.useEffect(()=>{if(!u.current)return;const o=h.getFocusableNodes(u.current);o.length>0?o[0].focus():console.warn("[FocusTrap]: it seems there are no focusable elements in the focus trap tree. Make sure there s at least one.")},[]);const K=o=>{if(o.key===g.KeyboardKeys.ESCAPE&&e){e();return}if(o.key!==g.KeyboardKeys.TAB)return;const n=h.getFocusableNodes(u.current);if(n.length>0){const i=n[0],d=n[n.length-1];o.shiftKey?i===document.activeElement&&(o.preventDefault(),d.focus()):d===document.activeElement&&(o.preventDefault(),i.focus())}};return k.default.createElement("div",m({ref:u,onKeyDown:K},s))};a.defaultProps={onEscape:void 0,restoreFocus:!0};a.propTypes={onEscape:v.default.func,restoreFocus:v.default.bool};exports.FocusTrap=a;
