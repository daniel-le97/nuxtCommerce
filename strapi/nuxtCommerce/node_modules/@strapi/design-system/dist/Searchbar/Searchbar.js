var z = Object.defineProperty;
var n = Object.getOwnPropertySymbols;
var u = Object.prototype.hasOwnProperty, d = Object.prototype.propertyIsEnumerable;
var c = (e, t, r) => t in e ? z(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, f = (e, t) => {
  for (var r in t || (t = {}))
    u.call(t, r) && c(e, r, t[r]);
  if (n)
    for (var r of n(t))
      d.call(t, r) && c(e, r, t[r]);
  return e;
};
var h = (e, t) => {
  var r = {};
  for (var o in e)
    u.call(e, o) && t.indexOf(o) < 0 && (r[o] = e[o]);
  if (e != null && n)
    for (var o of n(e))
      t.indexOf(o) < 0 && d.call(e, o) && (r[o] = e[o]);
  return r;
};
import l, { forwardRef as q, useRef as x } from "react";
import i from "prop-types";
import a from "styled-components";
import I from "@strapi/icons/Search";
import W from "@strapi/icons/Cross";
import { sizes as A } from "../themes/sizes.js";
import { Field as k } from "../Field/Field.js";
import { FieldLabel as L } from "../Field/FieldLabel.js";
import { InputWrapper as b, FieldInput as O } from "../Field/FieldInput.js";
import "../Field/FieldContext.js";
import "../Typography/Typography.js";
import { FieldAction as P } from "../Field/FieldAction.js";
import { VisuallyHidden as T } from "../VisuallyHidden/VisuallyHidden.js";
import { inputFocusStyle as _ } from "../themes/utils.js";
import { Flex as E } from "../Flex/Flex.js";
const j = a(E)`
  font-size: 0.5rem;
  svg path {
    fill: ${({ theme: e }) => e.colors.neutral400};
  }
`, R = a(E)`
  font-size: 0.8rem;

  svg path {
    fill: ${({ theme: e }) => e.colors.neutral800};
  }
`, H = a.div`
  border-radius: ${({ theme: e }) => e.borderRadius};
  box-shadow: ${({ theme: e }) => e.shadows.filterShadow};

  &:focus-within {
    ${R} {
      svg path {
        fill: ${({ theme: e }) => e.colors.primary600};
      }
    }
  }

  ${b} {
    border: 1px solid transparent;
  }

  ${_(b)}
`, s = q((M, S) => {
  var m = M, { name: e, size: t, children: r, value: o, onClear: g, clearLabel: y } = m, $ = h(m, ["name", "size", "children", "value", "onClear", "clearLabel"]);
  const p = x(null), v = o.length > 0, C = (w) => {
    g(w), p.current.focus();
  }, F = S || p;
  return /* @__PURE__ */ l.createElement(H, null, /* @__PURE__ */ l.createElement(k, {
    name: e
  }, /* @__PURE__ */ l.createElement(T, null, /* @__PURE__ */ l.createElement(L, null, r)), /* @__PURE__ */ l.createElement(O, f({
    ref: F,
    value: o,
    startAction: /* @__PURE__ */ l.createElement(R, null, /* @__PURE__ */ l.createElement(I, {
      "aria-hidden": !0
    })),
    size: t,
    endAction: v ? /* @__PURE__ */ l.createElement(P, {
      label: y,
      onClick: C
    }, /* @__PURE__ */ l.createElement(j, null, /* @__PURE__ */ l.createElement(W, null))) : void 0
  }, $))));
});
s.displayName = "Searchbar";
s.defaultProps = {
  value: "",
  size: "M"
};
s.propTypes = {
  children: i.node.isRequired,
  clearLabel: i.string.isRequired,
  name: i.string.isRequired,
  onClear: i.func.isRequired,
  size: i.oneOf(Object.keys(A.input)),
  value: i.string
};
export {
  s as Searchbar
};
