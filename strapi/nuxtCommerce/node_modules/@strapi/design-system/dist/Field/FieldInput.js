var B = Object.defineProperty;
var n = Object.getOwnPropertySymbols;
var g = Object.prototype.hasOwnProperty, b = Object.prototype.propertyIsEnumerable;
var f = (e, o, r) => o in e ? B(e, o, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[o] = r, h = (e, o) => {
  for (var r in o || (o = {}))
    g.call(o, r) && f(e, r, o[r]);
  if (n)
    for (var r of n(o))
      b.call(o, r) && f(e, r, o[r]);
  return e;
};
var $ = (e, o) => {
  var r = {};
  for (var t in e)
    g.call(e, t) && o.indexOf(t) < 0 && (r[t] = e[t]);
  if (e != null && n)
    for (var t of n(e))
      o.indexOf(t) < 0 && b.call(e, t) && (r[t] = e[t]);
  return r;
};
import i, { forwardRef as D } from "react";
import R from "styled-components";
import a from "prop-types";
import { sizes as O } from "../themes/sizes.js";
import { inputFocusStyle as z } from "../themes/utils.js";
import { useField as A } from "./FieldContext.js";
import { Flex as L } from "../Flex/Flex.js";
import { Box as y } from "../Box/Box.js";
const w = {
  S: 6.5,
  M: 10.5
}, M = R.input`
  border: none;
  border-radius: ${({ theme: e }) => e.borderRadius};
  padding-bottom: ${({ size: e }) => `${w[e] / 16}rem`};
  padding-left: ${({ theme: e, hasLeftAction: o }) => o ? 0 : e.spaces[4]};
  padding-right: ${({ theme: e, hasRightAction: o }) => o ? 0 : e.spaces[4]};
  padding-top: ${({ size: e }) => `${w[e] / 16}rem`};
  cursor: ${(e) => e["aria-disabled"] ? "not-allowed" : void 0};

  color: ${({ theme: e }) => e.colors.neutral800};
  font-weight: 400;
  // TODO: Make sure to use the theme when it's ready
  font-size: ${14 / 16}rem;
  display: block;
  width: 100%;
  background: inherit;

  ::placeholder {
    color: ${({ theme: e }) => e.colors.neutral500};
    opacity: 1;
  }

  &[aria-disabled='true'] {
    color: inherit;
  }

  //focus managed by InputWrapper
  &:focus {
    outline: none;
    box-shadow: none;
  }
`, P = R(L)`
  border: 1px solid ${({ theme: e, hasError: o }) => o ? e.colors.danger600 : e.colors.neutral200};
  border-radius: ${({ theme: e }) => e.borderRadius};
  background: ${({ theme: e }) => e.colors.neutral0};
  ${z()}

  ${({ theme: e, disabled: o }) => o ? `
    color: ${e.colors.neutral600};
    background: ${e.colors.neutral150};
  
  ` : void 0}
`, l = D((T, I) => {
  var c = T, { endAction: e, startAction: o, disabled: r, onChange: t, size: p } = c, k = $(c, ["endAction", "startAction", "disabled", "onChange", "size"]);
  const { id: d, error: u, hint: v, name: x, required: C } = A();
  let s;
  u ? s = `${d}-error` : v && (s = `${d}-hint`);
  const m = Boolean(u), E = (F) => {
    r || t(F);
  };
  return /* @__PURE__ */ i.createElement(P, {
    size: p,
    justifyContent: "space-between",
    hasError: m,
    disabled: r
  }, o && /* @__PURE__ */ i.createElement(y, {
    paddingLeft: 3,
    paddingRight: 2
  }, o), /* @__PURE__ */ i.createElement(M, h({
    id: d,
    name: x,
    ref: I,
    "aria-describedby": s,
    "aria-invalid": m,
    "aria-disabled": r,
    hasLeftAction: Boolean(o),
    hasRightAction: Boolean(e),
    onChange: E,
    "aria-required": C,
    size: p
  }, k)), e && /* @__PURE__ */ i.createElement(y, {
    paddingLeft: 2,
    paddingRight: 3
  }, e));
});
l.displayName = "FieldInput";
l.defaultProps = {
  disabled: !1,
  endAction: void 0,
  size: "M",
  startAction: void 0,
  onChange() {
  }
};
l.propTypes = {
  disabled: a.bool,
  endAction: a.element,
  onChange: a.func,
  size: a.oneOf(Object.keys(O.input)),
  startAction: a.element
};
export {
  l as FieldInput,
  P as InputWrapper
};
