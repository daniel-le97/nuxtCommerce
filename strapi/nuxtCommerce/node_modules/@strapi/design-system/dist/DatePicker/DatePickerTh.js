var c = Object.defineProperty;
var n = Object.getOwnPropertySymbols;
var m = Object.prototype.hasOwnProperty, p = Object.prototype.propertyIsEnumerable;
var a = (e, t, r) => t in e ? c(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, l = (e, t) => {
  for (var r in t || (t = {}))
    m.call(t, r) && a(e, r, t[r]);
  if (n)
    for (var r of n(t))
      p.call(t, r) && a(e, r, t[r]);
  return e;
};
var s = (e, t) => {
  var r = {};
  for (var o in e)
    m.call(e, o) && t.indexOf(o) < 0 && (r[o] = e[o]);
  if (e != null && n)
    for (var o of n(e))
      t.indexOf(o) < 0 && p.call(e, o) && (r[o] = e[o]);
  return r;
};
import i from "react";
import u from "prop-types";
import f from "styled-components";
import "../RawTable/RawTable.js";
import { RawTh as d } from "../RawTable/RawCell.js";
import "../RawTable/RawThead.js";
import "../RawTable/RawTbody.js";
import "../RawTable/RawTr.js";
import { Typography as h } from "../Typography/Typography.js";
import { VisuallyHidden as T } from "../VisuallyHidden/VisuallyHidden.js";
import { Flex as y } from "../Flex/Flex.js";
const g = f(d)`
  // Trick to prevent the outline from overflowing because of the general outline-offset
  outline-offset: -2px;
  border-radius: ${({ theme: e }) => e.borderRadius};
  text-transform: capitalize;
`, b = f(y)`
  height: ${24 / 16}rem;
  width: ${32 / 16}rem;
`, E = (r) => {
  var o = r, { children: e } = o, t = s(o, ["children"]);
  return /* @__PURE__ */ i.createElement(g, l({}, t), /* @__PURE__ */ i.createElement(b, {
    justifyContent: "center"
  }, /* @__PURE__ */ i.createElement(h, {
    variant: "pi",
    fontWeight: "bold",
    color: "neutral800",
    "aria-hidden": !0
  }, e.substr(0, 2)), /* @__PURE__ */ i.createElement(T, null, /* @__PURE__ */ i.createElement("span", null, e))));
};
E.propTypes = {
  children: u.string.isRequired
};
export {
  E as DatePickerTh
};
