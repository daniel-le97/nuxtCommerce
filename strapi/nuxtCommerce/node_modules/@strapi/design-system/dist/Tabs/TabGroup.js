var C = Object.defineProperty;
var i = Object.getOwnPropertySymbols;
var f = Object.prototype.hasOwnProperty, u = Object.prototype.propertyIsEnumerable;
var m = (e, r, a) => r in e ? C(e, r, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[r] = a, T = (e, r) => {
  for (var a in r || (r = {}))
    f.call(r, a) && m(e, a, r[a]);
  if (i)
    for (var a of i(r))
      u.call(r, a) && m(e, a, r[a]);
  return e;
};
var v = (e, r) => {
  var a = {};
  for (var t in e)
    f.call(e, t) && r.indexOf(t) < 0 && (a[t] = e[t]);
  if (e != null && i)
    for (var t of i(e))
      r.indexOf(t) < 0 && u.call(e, t) && (a[t] = e[t]);
  return a;
};
import I, { forwardRef as R, Children as S, useState as P, useImperativeHandle as _ } from "react";
import d from "prop-types";
import { TabsContext as q } from "./TabsContext.js";
import { useId as E } from "../helpers/useId.js";
const s = R((G, x) => {
  var p = G, { id: e, initialSelectedTabIndex: r, label: a, onTabChange: t, variant: h } = p, l = v(p, ["id", "initialSelectedTabIndex", "label", "onTabChange", "variant"]);
  const y = E("tabgroup", e), b = S.toArray(l.children).find((o) => o.type.displayName === "Tabs");
  let n = r || 0;
  b && r === void 0 && (n = b.props.children.findIndex((o) => !o.props.disabled));
  const [g, c] = P(n === -1 ? 0 : n);
  return _(x, () => ({
    _handlers: { setSelectedTabIndex: c }
  })), /* @__PURE__ */ I.createElement(q.Provider, {
    value: { id: y, selectedTabIndex: g, selectTabIndex: c, label: a, variant: h, onTabChange: t }
  }, /* @__PURE__ */ I.createElement("div", T({}, l)));
});
s.displayName = "TabGroup";
s.defaultProps = {
  id: void 0,
  initialSelectedTabIndex: void 0,
  onTabChange() {
  },
  variant: void 0
};
s.propTypes = {
  children: d.node.isRequired,
  id: d.string,
  initialSelectedTabIndex: d.number,
  label: d.string.isRequired,
  onTabChange: d.func,
  variant: d.oneOf(["simple"])
};
export {
  s as TabGroup
};
