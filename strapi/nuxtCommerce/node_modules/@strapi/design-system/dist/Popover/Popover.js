var L = Object.defineProperty;
var i = Object.getOwnPropertySymbols;
var b = Object.prototype.hasOwnProperty, g = Object.prototype.propertyIsEnumerable;
var h = (e, o, t) => o in e ? L(e, o, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[o] = t, p = (e, o) => {
  for (var t in o || (o = {}))
    b.call(o, t) && h(e, t, o[t]);
  if (i)
    for (var t of i(o))
      g.call(o, t) && h(e, t, o[t]);
  return e;
};
var w = (e, o) => {
  var t = {};
  for (var r in e)
    b.call(e, r) && o.indexOf(r) < 0 && (t[r] = e[r]);
  if (e != null && i)
    for (var r of i(e))
      o.indexOf(r) < 0 && g.call(e, r) && (t[r] = e[r]);
  return t;
};
import * as s from "react";
import n from "prop-types";
import v from "styled-components";
import { useFloating as z, offset as A, shift as C, flip as M, autoUpdate as B } from "@floating-ui/react-dom";
import { Box as d } from "../Box/Box.js";
import { Portal as D } from "../Portal/Portal.js";
import { useIntersection as F } from "../helpers/useIntersection.js";
const N = [
  "top",
  "top-start",
  "top-end",
  "right",
  "right-start",
  "right-end",
  "bottom",
  "bottom-start",
  "bottom-end",
  "left",
  "left-start",
  "left-end"
], U = v(d)`
  box-shadow: ${({ theme: e }) => e.shadows.filterShadow};
  z-index: 4;
  border: 1px solid ${({ theme: e }) => e.colors.neutral150};
  background: ${({ theme: e }) => e.colors.neutral0};
`, V = v(d)`
  // 16 is base base size, 3 is the factor to get closer to 40px and 5 is the number of elements visible in the list
  max-height: ${3 * 5}rem;
  overflow-y: auto;
  overflow-x: hidden;

  &::-webkit-scrollbar {
    -webkit-appearance: none;
    width: 4px;
  }

  &::-webkit-scrollbar-track {
    background: ${({ theme: e }) => e.colors.neutral0};
  }

  &::-webkit-scrollbar-thumb {
    background: ${({ theme: e }) => e.colors.neutral150};
    border-radius: ${({ theme: e }) => e.borderRadius};
    margin-right: 10px;
  }
`, c = (_) => {
  var f = _, {
    source: e,
    children: o,
    spacing: t,
    fullWidth: r,
    placement: P,
    onReachEnd: l,
    intersectionId: a,
    centered: k
  } = f, R = w(f, [
    "source",
    "children",
    "spacing",
    "fullWidth",
    "placement",
    "onReachEnd",
    "intersectionId",
    "centered"
  ]);
  const u = s.useRef(null), [$, W] = s.useState(void 0), { x: T, y: O, reference: m, floating: S, strategy: q } = z({
    strategy: "fixed",
    placement: k ? "bottom" : P,
    middleware: [
      A({
        mainAxis: t
      }),
      C(),
      M()
    ],
    whileElementsMounted: B
  });
  return s.useLayoutEffect(() => {
    m(e.current);
  }, [e, m]), s.useLayoutEffect(() => {
    r && W(e.current.offsetWidth);
  }, [r, e]), F(u, l, {
    selectorToWatch: `#${a}`,
    skipWhen: !a || !l
  }), /* @__PURE__ */ s.createElement(U, {
    ref: S,
    style: {
      left: T,
      top: O,
      position: q,
      width: $ || void 0
    },
    hasRadius: !0,
    background: "neutral0",
    padding: 1
  }, /* @__PURE__ */ s.createElement(V, p({
    ref: u
  }, R), o, a && l && /* @__PURE__ */ s.createElement(d, {
    id: a,
    width: "100%",
    height: "1px"
  })));
}, x = (e) => /* @__PURE__ */ s.createElement(D, null, /* @__PURE__ */ s.createElement(c, p({}, e))), y = {
  fullWidth: !1,
  intersectionId: void 0,
  onReachEnd: void 0,
  centered: !1,
  placement: "bottom-start",
  spacing: 0
}, E = {
  centered: n.bool,
  children: n.node.isRequired,
  fullWidth: n.bool,
  intersectionId: n.string,
  onReachEnd: n.func,
  placement: n.oneOf(N),
  source: n.shape({
    current: (typeof Element == "undefined" ? n.any : n.instanceOf(Element)).isRequired
  }).isRequired,
  spacing: n.number
};
c.propTypes = E;
c.defaultProps = y;
x.propTypes = E;
x.defaultProps = y;
export {
  N as POPOVER_PLACEMENTS,
  x as Popover
};
