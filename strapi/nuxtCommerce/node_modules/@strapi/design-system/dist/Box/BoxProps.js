var p = Object.defineProperty;
var d = Object.getOwnPropertySymbols;
var t = Object.prototype.hasOwnProperty, g = Object.prototype.propertyIsEnumerable;
var i = (n, r, e) => r in n ? p(n, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[r] = e, a = (n, r) => {
  for (var e in r || (r = {}))
    t.call(r, e) && i(n, e, r[e]);
  if (d)
    for (var e of d(r))
      g.call(r, e) && i(n, e, r[e]);
  return n;
};
import f from "react";
import o from "prop-types";
const s = (n) => /* @__PURE__ */ f.createElement("div", a({}, n)), b = {
  background: void 0,
  borderColor: void 0,
  color: void 0,
  hiddenS: !1,
  hiddenXS: !1,
  padding: void 0,
  paddingTop: void 0,
  paddingRight: void 0,
  paddingBottom: void 0,
  paddingLeft: void 0,
  hasRadius: !1,
  shadow: void 0,
  children: null,
  shrink: void 0,
  grow: void 0,
  basis: void 0,
  flex: void 0,
  _hover: () => {
  }
}, l = {
  _hover: o.func,
  background: o.string,
  basis: o.oneOfType([o.string, o.string]),
  borderColor: o.string,
  children: o.oneOfType([o.node, o.string]),
  color: o.string,
  flex: o.oneOfType([o.string, o.string]),
  grow: o.oneOfType([o.string, o.string]),
  hasRadius: o.bool,
  hiddenS: o.bool,
  hiddenXS: o.bool,
  padding: o.oneOfType([o.number, o.arrayOf(o.number)]),
  paddingBottom: o.oneOfType([o.number, o.arrayOf(o.number)]),
  paddingLeft: o.oneOfType([o.number, o.arrayOf(o.number)]),
  paddingRight: o.oneOfType([o.number, o.arrayOf(o.number)]),
  paddingTop: o.oneOfType([o.number, o.arrayOf(o.number)]),
  shadow: o.string,
  shrink: o.oneOfType([o.string, o.string])
};
s.defaultProps = b;
s.propTypes = l;
export {
  s as BoxProps,
  b as boxDefaultProps,
  l as boxPropTypes
};
