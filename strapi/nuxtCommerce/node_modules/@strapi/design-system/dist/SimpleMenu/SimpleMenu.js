var Y = Object.defineProperty;
var C = Object.getOwnPropertySymbols;
var F = Object.prototype.hasOwnProperty, V = Object.prototype.propertyIsEnumerable;
var N = (e, r, t) => r in e ? Y(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[r] = t, p = (e, r) => {
  for (var t in r || (r = {}))
    F.call(r, t) && N(e, t, r[t]);
  if (C)
    for (var t of C(r))
      V.call(r, t) && N(e, t, r[t]);
  return e;
};
var b = (e, r) => {
  var t = {};
  for (var s in e)
    F.call(e, s) && r.indexOf(s) < 0 && (t[s] = e[s]);
  if (e != null && C)
    for (var s of C(e))
      r.indexOf(s) < 0 && V.call(e, s) && (t[s] = e[s]);
  return t;
};
import i, { useRef as w, useEffect as P, useState as q, Children as Z, cloneElement as ee } from "react";
import n from "prop-types";
import h from "styled-components";
import { NavLink as ne } from "react-router-dom";
import { useCallbackRef as W } from "@radix-ui/react-use-callback-ref";
import te from "@strapi/icons/CarretDown";
import { Typography as S } from "../Typography/Typography.js";
import { Link as oe } from "../Link/Link.js";
import { Box as R } from "../Box/Box.js";
import { Flex as re } from "../Flex/Flex.js";
import { Button as _ } from "../Button/Button.js";
import { POPOVER_PLACEMENTS as ie, Popover as se } from "../Popover/Popover.js";
import { getOptionStyle as M } from "./utils.js";
import { useId as ae } from "../helpers/useId.js";
import { KeyboardKeys as c } from "../helpers/keyboardKeys.js";
const le = h.button`
  border: none;
  padding: 0;
  background: transparent;
  cursor: pointer;
  ${M}
`, ce = h(ne)`
  text-decoration: none;
  ${M}
`, pe = h(oe)`
  /* Removing Link hover effect */
  &:hover {
    color: currentColor;
  }

  &:focus-visible {
    /* Removing Link focus-visible after properties and reset to global outline */
    outline: 2px solid ${({ theme: e }) => e.colors.primary600};
    outline-offset: 2px;
    &:after {
      content: none;
    }
  }

  ${M}
`, ue = h.span`
  display: flex;
  align-items: center;
  svg {
    height: 4px;
    width: 6px;
  }
`, me = h(_)`
  padding: ${({ theme: e }) => `${e.spaces[1]} ${e.spaces[3]}`};
`, z = (B) => {
  var v = B, { children: e, onClick: r, to: t, isFocused: s, href: u } = v, D = b(v, ["children", "onClick", "to", "isFocused", "href"]);
  const l = w();
  P(() => {
    s && l.current && l.current.focus();
  }, [s]);
  const m = p({
    tabIndex: s ? 0 : -1,
    ref: l,
    role: "menuitem"
  }, D), K = (f) => {
    (f.key === c.SPACE || f.key === c.ENTER) && r();
  };
  return t && !u ? /* @__PURE__ */ i.createElement(ce, p({
    to: t
  }, m), /* @__PURE__ */ i.createElement(R, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(S, null, e))) : u && !t ? /* @__PURE__ */ i.createElement(pe, p({
    isExternal: !0,
    href: u
  }, m), /* @__PURE__ */ i.createElement(R, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(S, null, e))) : /* @__PURE__ */ i.createElement(le, p({
    onKeyDown: K,
    onMouseDown: r,
    type: "button"
  }, m), /* @__PURE__ */ i.createElement(R, {
    padding: 2
  }, /* @__PURE__ */ i.createElement(S, null, e)));
};
z.defaultProps = {
  as: void 0,
  href: void 0,
  isFocused: !1,
  onClick() {
  },
  to: void 0
};
z.propTypes = {
  as: n.elementType,
  children: n.node.isRequired,
  href: n.string,
  isFocused: n.bool,
  onClick: n.func,
  to: n.string
};
const x = (K) => {
  var f = K, {
    label: e,
    children: r,
    id: t,
    as: s,
    onOpen: u = () => {
    },
    onClose: D = () => {
    },
    size: B,
    popoverPlacement: v,
    onReachEnd: l
  } = f, m = b(f, [
    "label",
    "children",
    "id",
    "as",
    "onOpen",
    "onClose",
    "size",
    "popoverPlacement",
    "onReachEnd"
  ]);
  const d = w(), I = ae("simplemenu", t), y = w(!1), [E, g] = q(!1), [O, T] = q(0), k = Z.toArray(r), j = s || (B === "S" ? me : _), $ = !!l && typeof l == "function";
  P(() => {
    if (["string", "number"].includes(typeof e)) {
      const o = k.findIndex((a) => a.props.children === e);
      o !== -1 && T(o);
    }
  }, [e]);
  const L = W(u), A = W(D);
  P(() => {
    y != null && y.current ? E ? L() : A() : y.current = !0;
  }, [y, A, L, E]), P(() => {
    i.isValidElement(e) && O === -1 && d.current.focus();
  }, [e, O]);
  const H = (o) => {
    E && (o.key === c.ESCAPE && (o.stopPropagation(), g(!1), d.current.focus()), o.key === c.DOWN && T((a) => a === k.length - 1 ? 0 : a + 1), o.key === c.UP && T((a) => a === 0 ? k.length - 1 : a - 1));
  }, U = (o) => {
    (o.key === c.ENTER || o.key === c.SPACE) && g((a) => !a);
  }, G = (o) => {
    o.preventDefault(), o.currentTarget.contains(o.relatedTarget) || g(!1);
  }, J = (o) => {
    o.preventDefault(), g((a) => !a);
  }, Q = () => {
    $ && l();
  }, X = k.map((o, a) => /* @__PURE__ */ i.createElement(re, {
    as: "li",
    key: a,
    justifyContent: "center",
    role: "menuitem"
  }, ee(o, {
    onClick() {
      o.props.onClick(), g(!1), d.current.focus();
    },
    isFocused: O === a
  })));
  return /* @__PURE__ */ i.createElement("div", {
    onKeyDown: H
  }, /* @__PURE__ */ i.createElement(j, p({
    label: i.isValidElement(e) ? null : e,
    "aria-haspopup": !0,
    "aria-expanded": E,
    "aria-controls": I,
    onKeyDown: U,
    onMouseDown: J,
    ref: d,
    type: "button",
    variant: "ghost",
    endIcon: /* @__PURE__ */ i.createElement(ue, null, /* @__PURE__ */ i.createElement(te, {
      "aria-hidden": !0
    }))
  }, m), e), E && /* @__PURE__ */ i.createElement(se, {
    onBlur: G,
    placement: v,
    source: d,
    onReachEnd: Q,
    intersectionId: $ ? `popover-${I}` : void 0,
    spacing: 4
  }, /* @__PURE__ */ i.createElement(R, {
    role: "menu",
    as: "ul",
    padding: 1,
    id: I
  }, X)));
};
x.defaultProps = {
  as: void 0
};
x.displayName = "SimpleMenu";
x.defaultProps = {
  id: void 0,
  onOpen: void 0,
  onClose: void 0,
  onReachEnd: void 0,
  popoverPlacement: "bottom-start",
  size: "M"
};
x.propTypes = {
  as: n.any,
  children: n.oneOfType([n.arrayOf(n.node), n.node]).isRequired,
  id: n.string,
  label: n.oneOfType([n.string, n.number, n.element]).isRequired,
  onClose: n.func,
  onOpen: n.func,
  onReachEnd: n.func,
  popoverPlacement: n.oneOf(ie),
  size: n.oneOf(["S", "M"])
};
export {
  z as MenuItem,
  x as SimpleMenu
};
