var x = Object.defineProperty;
var n = Object.getOwnPropertySymbols;
var d = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;
var m = (e, t, r) => t in e ? x(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, h = (e, t) => {
  for (var r in t || (t = {}))
    d.call(t, r) && m(e, r, t[r]);
  if (n)
    for (var r of n(t))
      c.call(t, r) && m(e, r, t[r]);
  return e;
};
var p = (e, t) => {
  var r = {};
  for (var i in e)
    d.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
  if (e != null && n)
    for (var i of n(e))
      t.indexOf(i) < 0 && c.call(e, i) && (r[i] = e[i]);
  return r;
};
import o, { Children as f } from "react";
import a from "prop-types";
import E from "styled-components";
import { Box as T } from "../../Box/Box.js";
import { Divider as A } from "./Divider.js";
import { Flex as u } from "../../Flex/Flex.js";
const B = E(u)`
  // CrumbLinks do have padding-x, because they need to have a
  // interaction effect, which mis-aligns the breadcrumbs on the left.
  // This normalizes the behavior by moving the first item to left by
  // the same amount it has inner padding
  :first-child {
    margin-left: ${({ theme: e }) => `calc(-1*${e.spaces[2]})`};
  }
`, y = (i) => {
  var s = i, { label: e, children: t } = s, r = p(s, ["label", "children"]);
  const l = f.toArray(t);
  return /* @__PURE__ */ o.createElement(T, h({
    "aria-label": e
  }, r), /* @__PURE__ */ o.createElement(B, {
    as: "ol",
    horizontal: !0
  }, f.map(l, (b, g) => {
    const v = l.length > 1 && g + 1 < l.length;
    return /* @__PURE__ */ o.createElement(u, {
      inline: !0,
      as: "li"
    }, b, v && /* @__PURE__ */ o.createElement(A, null));
  })));
};
y.displayName = "Breadcrumbs";
y.propTypes = {
  children: a.oneOfType([a.arrayOf(a.node), a.node]).isRequired,
  label: a.string.isRequired
};
export {
  y as Breadcrumbs
};
