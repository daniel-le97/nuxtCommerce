var J = Object.defineProperty;
var C = Object.getOwnPropertySymbols;
var A = Object.prototype.hasOwnProperty, N = Object.prototype.propertyIsEnumerable;
var $ = (e, t, o) => t in e ? J(e, t, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[t] = o, u = (e, t) => {
  for (var o in t || (t = {}))
    A.call(t, o) && $(e, o, t[o]);
  if (C)
    for (var o of C(t))
      N.call(t, o) && $(e, o, t[o]);
  return e;
};
var T = (e, t) => {
  var o = {};
  for (var i in e)
    A.call(e, i) && t.indexOf(i) < 0 && (o[i] = e[i]);
  if (e != null && C)
    for (var i of C(e))
      t.indexOf(i) < 0 && N.call(e, i) && (o[i] = e[i]);
  return o;
};
import s, { useRef as w, useEffect as x, useState as F, Children as Q, cloneElement as X } from "react";
import n from "prop-types";
import E from "styled-components";
import { useCallbackRef as V } from "@radix-ui/react-use-callback-ref";
import Y from "@strapi/icons/CarretDown";
import { Link as Z } from "../Link/Link.js";
import { Typography as S } from "../../Typography/Typography.js";
import { Box as v } from "../../Box/Box.js";
import { Flex as ee } from "../../Flex/Flex.js";
import { Button as q } from "../../Button/Button.js";
import { BaseLink as ne } from "../../BaseLink/BaseLink.js";
import { POPOVER_PLACEMENTS as te, Popover as oe } from "../../Popover/Popover.js";
import { getOptionStyle as B } from "./utils.js";
import { useId as re } from "../../helpers/useId.js";
import { KeyboardKeys as c } from "../../helpers/keyboardKeys.js";
const se = E.button`
  border: none;
  padding: 0;
  background: transparent;
  cursor: pointer;
  ${B}
`, ie = E(ne)`
  text-decoration: none;
  ${B}
`, ae = E(Z)`
  &:focus-visible {
    /* Removes Link focus-visible after properties and reset to global outline */
    outline: 2px solid ${({ theme: e }) => e.colors.primary600};
    outline-offset: 2px;
    &:after {
      content: none;
    }
  }
  /* Removes Link svg color */
  svg path {
    fill: currentColor;
  }
  ${B}
`, le = E.span`
  display: flex;
  align-items: center;
  svg {
    height: 4px;
    width: 6px;
  }
`, ce = E(q)`
  padding: ${({ theme: e }) => `${e.spaces[1]} ${e.spaces[3]}`};
`, W = (L) => {
  var g = L, { as: e, children: t, onClick: o, isFocused: i, isLink: D, isExternal: O } = g, b = T(g, ["as", "children", "onClick", "isFocused", "isLink", "isExternal"]);
  const k = w();
  x(() => {
    i && k.current && k.current.focus();
  }, [i]);
  const p = u({
    tabIndex: i ? 0 : -1,
    ref: k,
    role: "menuitem"
  }, b), l = (m) => {
    (m.key === c.SPACE || m.key === c.ENTER) && o();
  };
  return D ? /* @__PURE__ */ s.createElement(ie, u({
    as: e
  }, p), /* @__PURE__ */ s.createElement(v, {
    padding: 2
  }, /* @__PURE__ */ s.createElement(S, null, t))) : O ? /* @__PURE__ */ s.createElement(ae, u({
    isExternal: !0
  }, p), /* @__PURE__ */ s.createElement(v, {
    padding: 2
  }, /* @__PURE__ */ s.createElement(S, null, t))) : /* @__PURE__ */ s.createElement(se, u({
    onKeyDown: l,
    onMouseDown: o,
    type: "button"
  }, p), /* @__PURE__ */ s.createElement(v, {
    padding: 2
  }, /* @__PURE__ */ s.createElement(S, null, t)));
};
W.defaultProps = {
  as: void 0,
  onClick() {
  },
  isExternal: !1,
  isFocused: !1,
  isLink: !1
};
W.propTypes = {
  as: n.elementType,
  children: n.node.isRequired,
  isExternal: n.bool,
  isFocused: n.bool,
  isLink: n.bool,
  onClick: n.func
};
const P = (k) => {
  var p = k, {
    label: e,
    children: t,
    id: o,
    as: i,
    onOpen: D = () => {
    },
    onClose: O = () => {
    },
    size: b,
    popoverPlacement: L
  } = p, g = T(p, [
    "label",
    "children",
    "id",
    "as",
    "onOpen",
    "onClose",
    "size",
    "popoverPlacement"
  ]);
  const l = w(), m = re("simplemenu", o), f = w(!1), [d, y] = F(!1), [I, R] = F(0), h = Q.toArray(t), _ = i || (b === "S" ? ce : q);
  x(() => {
    if (["string", "number"].includes(typeof e)) {
      const r = h.findIndex((a) => a.props.children === e);
      r !== -1 && R(r);
    }
  }, [e]);
  const M = V(D), K = V(O);
  x(() => {
    f != null && f.current ? d ? M() : K() : f.current = !0;
  }, [f, d, M, K]), x(() => {
    s.isValidElement(e) && I === -1 && l.current.focus();
  }, [e, I]);
  const z = (r) => {
    d && (r.key === c.ESCAPE && (r.stopPropagation(), y(!1), l.current.focus()), r.key === c.DOWN && R((a) => a === h.length - 1 ? 0 : a + 1), r.key === c.UP && R((a) => a === 0 ? h.length - 1 : a - 1));
  }, j = (r) => {
    (r.key === c.ENTER || r.key === c.SPACE) && y((a) => !a);
  }, U = (r) => {
    r.preventDefault(), r.currentTarget.contains(r.relatedTarget) || y(!1);
  }, G = (r) => {
    r.preventDefault(), y((a) => !a);
  }, H = h.map((r, a) => /* @__PURE__ */ s.createElement(ee, {
    as: "li",
    key: a,
    justifyContent: "center",
    role: "menuitem"
  }, X(r, {
    onClick() {
      r.props.onClick(), y(!1), l.current.focus();
    },
    isFocused: I === a
  })));
  return /* @__PURE__ */ s.createElement("div", {
    onKeyDown: z
  }, /* @__PURE__ */ s.createElement(_, u({
    label: s.isValidElement(e) ? null : e,
    "aria-haspopup": !0,
    "aria-expanded": d,
    "aria-controls": m,
    onKeyDown: j,
    onMouseDown: G,
    ref: l,
    type: "button",
    variant: "ghost",
    endIcon: /* @__PURE__ */ s.createElement(le, null, /* @__PURE__ */ s.createElement(Y, {
      "aria-hidden": !0
    }))
  }, g), e), d && /* @__PURE__ */ s.createElement(oe, {
    onBlur: U,
    placement: L,
    source: l,
    spacing: 4
  }, /* @__PURE__ */ s.createElement(v, {
    role: "menu",
    as: "ul",
    padding: 1,
    id: m
  }, H)));
};
P.defaultProps = {
  as: void 0
};
P.displayName = "SimpleMenu";
P.defaultProps = {
  id: void 0,
  onClose() {
  },
  onOpen() {
  },
  popoverPlacement: "bottom-start",
  size: "M"
};
P.propTypes = {
  as: n.any,
  children: n.oneOfType([n.arrayOf(n.node), n.node]).isRequired,
  id: n.string,
  label: n.oneOfType([n.string, n.number, n.element]).isRequired,
  onClose: n.func,
  onOpen: n.func,
  popoverPlacement: n.oneOf(te),
  size: n.oneOf(["S", "M"])
};
export {
  W as MenuItem,
  P as SimpleMenu
};
